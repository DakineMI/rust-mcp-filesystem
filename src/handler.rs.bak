use std::cmp::Ordering;

use crate::cli::CommandArguments;
use crate::error::ServiceError;
use crate::{error::ServiceResult, fs_service::FileSystemService, tools::*};
use async_trait::async_trait;
use rust_mcp_sdk::mcp_server::ServerHandler;
use rust_mcp_sdk::schema::{
    schema_utils::CallToolError, CallToolRequest, CallToolResult, InitializeRequest,
    InitializeResult, ListToolsRequest, ListToolsResult, RpcError,
};
use rust_mcp_sdk::McpServer;

pub struct MyServerHandler {
    readonly: bool,
    fs_service: FileSystemService,
}

impl MyServerHandler {
    pub fn new(args: &CommandArguments) -> ServiceResult<Self> {
        let fs_service = FileSystemService::try_new(&args.allowed_directories)?;
        Ok(Self {
            fs_service,
            readonly: !&args.allow_write,
        })
    }

    pub fn assert_write_access(&self) -> std::result::Result<(), CallToolError> {
        if self.readonly {
            Err(CallToolError::new(ServiceError::NoWriteAccess))
        } else {
            Ok(())
        }
    }

    pub fn startup_message(&self) -> String {
        format!(
            "Secure MCP Filesystem Server running in \"{}\" mode.\nAllowed directories:\n{}",
            if !self.readonly {
                "read/write"
            } else {
                "readonly"
            },
            self.fs_service
                .allowed_directories()
                .iter()
                .map(|p| p.display().to_string())
                .collect::<Vec<String>>()
                .join(",\n")
        )
    }

    fn create_tool_parse_error(error: impl std::fmt::Display, tool_name: &str) -> CallToolError {
        let error_details = Self::analyze_json_error(&error.to_string(), tool_name);
        let error_msg = format!(
            "❌ JSON validation failed for tool '{}'\n\n🔍 Problem: {}\n\n📝 Correct format:\n{}",
            tool_name,
            error_details,
            Self::get_tool_example(tool_name)
        );
        CallToolError::new(ServiceError::FromString(error_msg))
    }

    fn analyze_json_error(error: &str, tool_name: &str) -> String {
        if error.contains("missing field") {
            let field = error.split("missing field `").nth(1)
                .and_then(|s| s.split('`').next())
                .unwrap_or("unknown");
            format!("Required field '{}' is missing from your request", field)
        } else if error.contains("unknown field") {
            let field = error.split("unknown field `").nth(1)
                .and_then(|s| s.split('`').next())
                .unwrap_or("unknown");
            format!("Field '{}' is not recognized. Check parameter names", field)
        } else if error.contains("invalid type") {
            format!("One of the parameter values has an incorrect data type")
        } else if error.contains("expected") {
            format!("Parameter format issue - check the expected JSON structure")
        } else {
            format!("JSON parsing error: {}", error)
        }
    }

    fn get_tool_example(tool_name: &str) -> &'static str {
        match tool_name {
            "search_and_replace" => r#"{
  "path": "/path/to/file.txt",        // Required: File path (absolute or relative)
  "edits": [                          // Required: Array of text replacements
    {
      "old_text": "text to find",      // Required: Text to search for
      "new_text": "replacement text",  // Required: Text to replace with
      "mode": "exact"                  // Optional: "exact" or "regex" (default: "exact")
    }
  ],
  "dry_run": false                     // Optional: Preview changes without writing (default: false)
}"#,
            "edit_file" => r#"{
  "path": "/path/to/file.txt",        // Required: File path (absolute or relative)
  "edits": [                          // Required: Array of text replacements
    {
      "old_text": "text to find",      // Required: Text to search for
      "new_text": "replacement text"   // Required: Text to replace with
    }
  ],
  "dry_run": false                     // Optional: Preview changes without writing (default: false)
}"#,
            "read_file" => r#"{
  "path": "/path/to/file.txt"          // Required: File path (absolute or relative)
}"#,
            "write_file" => r#"{
  "path": "/path/to/file.txt",         // Required: File path (absolute or relative)
  "content": "file content here"        // Required: Content to write to file
}"#,
            "move_file" => r#"{
  "source": "/path/to/source",         // Required: Source file/directory path
  "destination": "/path/to/destination" // Required: Destination file/directory path
}"#,
            _ => r#"{
  "path": "/path/to/file.txt"          // Most tools require a path parameter
  // Additional parameters vary by tool - see documentation
}"#,
        }
    }
}

#[async_trait]
impl ServerHandler for MyServerHandler {
    async fn on_server_started(&self, runtime: &dyn McpServer) {
        let _ = runtime.stderr_message(self.startup_message()).await;
    }

    async fn on_initialized(&self, _: &dyn McpServer) {}

    async fn handle_list_tools_request(
        &self,
        _: ListToolsRequest,
        _: &dyn McpServer,
    ) -> std::result::Result<ListToolsResult, RpcError> {
        Ok(ListToolsResult {
            tools: FileSystemTools::tools(),
            meta: None,
            next_cursor: None,
        })
    }

    async fn handle_initialize_request(
        &self,
        initialize_request: InitializeRequest,
        runtime: &dyn McpServer,
    ) -> std::result::Result<InitializeResult, RpcError> {
        // Set client details if supported by the runtime
        std::mem::drop(runtime.set_client_details(initialize_request.params.clone()));

        let mut server_info = runtime.server_info().to_owned();
        // Provide compatibility for clients using older MCP protocol versions.
        if server_info
            .protocol_version
            .cmp(&initialize_request.params.protocol_version)
            == Ordering::Greater
        {
            server_info.protocol_version = initialize_request.params.protocol_version;
        }
        Ok(server_info)
    }

    async fn handle_call_tool_request(
        &self,
        request: CallToolRequest,
        _: &dyn McpServer,
    ) -> std::result::Result<CallToolResult, CallToolError> {
        let tool_params: FileSystemTools = match FileSystemTools::try_from(request.params.clone()) {
            Ok(params) => params,
            Err(err) => {
                return Err(Self::create_tool_parse_error(err, "filesystem"));
            }
        };

        // Verify write access for tools that modify the file system
        if tool_params.require_write_access() {
            self.assert_write_access()?;
        }

        match tool_params {
            FileSystemTools::ReadFileTool(params) => {
                ReadFileTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::ReadMultipleFilesTool(params) => {
                ReadMultipleFilesTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::WriteFileTool(params) => {
                WriteFileTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::EditFileTool(params) => {
                EditFileTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::SearchReplaceTool(params) => {
                SearchReplaceTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::CreateDirectoryTool(params) => {
                CreateDirectoryTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::ListDirectoryTool(params) => {
                ListDirectoryTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::DirectoryTreeTool(params) => {
                DirectoryTreeTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::MoveFileTool(params) => {
                MoveFileTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::SearchFilesTool(params) => {
                SearchFilesTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::GetFileInfoTool(params) => {
                GetFileInfoTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::ListAllowedDirectoriesTool(params) => {
                ListAllowedDirectoriesTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::ZipFilesTool(params) => {
                ZipFilesTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::UnzipFileTool(params) => {
                UnzipFileTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::ZipDirectoryTool(params) => {
                ZipDirectoryTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::SearchFilesContentTool(params) => {
                SearchFilesContentTool::run_tool(params, &self.fs_service).await
            }
            FileSystemTools::ListDirectoryWithSizesTool(params) => {
                ListDirectoryWithSizesTool::run_tool(params, &self.fs_service).await
            }
        }
    }
}